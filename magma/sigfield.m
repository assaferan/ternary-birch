// Signature functions for number fields.

intrinsic SignatureGF2(x::FldRatElt) -> ModTupFldElt
{Internal}
  return Vector(GF(2), [ (1-Sign(x)) div 2] );
end intrinsic;

intrinsic SignatureGF2(x::FldAlgElt[FldRat]) -> ModTupFldElt
{"} //"
  return Vector(GF(2), [ e eq 1 select 0 else 1 : e in Signature(x) ]);
end intrinsic;

intrinsic SignatureGF2(x::RngIntElt) -> ModTupFldElt
{"} //"
  return Vector(GF(2), [ (1-Sign(x)) div 2] );
end intrinsic;

intrinsic SignatureGF2(x::RngOrdElt[RngInt]) -> ModTupFldElt
{"} //"
  x:= NumberField(Parent(x)) ! x;
  return Vector(GF(2), [ e eq 1 select 0 else 1 : e in Signature(x) ]);
end intrinsic;

intrinsic SignatureMatrix(K::FldAlg[FldRat]) -> AlgMatElt, []
{Returns a matrix S and a list U of generators of Z_K^*. The i-th row of S contains the signature of U[i]}
  U, map:= UnitGroup(Integers(K));
  Units:= [map(U.i): i in [1..NumberOfGenerators(U)]]; 
  return Matrix([SignatureGF2(u): u in Units]), Units;
end intrinsic;

intrinsic SignatureMatrix(K::FldRat) -> AlgMatElt, []
{"} //"
  return Matrix(GF(2), 1, [1]), [-1];
end intrinsic;

intrinsic SignatureMatrix(K::RngInt) -> AlgMatElt, []
{"} //"
  return Matrix(GF(2), 1, [1]), [-1];
end intrinsic;

intrinsic SignatureMatrix(K::RngOrd[RngInt]) -> AlgMatElt, []
{"} //"
  return SignatureMatrix(NumberField(K));
end intrinsic;

intrinsic UnitWithSignature(K::FldAlg[FldRat], sig::ModTupFldElt) -> BoolElt, SeqEnum
{ Returns true iff there exists a unit in Z_K that has signature vector sig.
  If so, the second return value contains a list of all such units modulo squares}

  S, Units:= SignatureMatrix(K);
  require BaseRing(sig) cmpeq GF(2) and Dimension(Parent(sig)) eq Ncols(S) : "Wrong signature vector";
  
  ok, x, V:= IsConsistent(S, sig);
  if ok then 
    V:= [x+v: v in V];
    return true, [ &*([K | Units[i]: i in [1..#Units] | v[i] ne 0]): v in V ];
  else 
    return false, _;
  end if;
end intrinsic;

intrinsic UnitWithSignature(K::FldRat, sig::ModTupFldElt) -> BoolElt, SeqEnum
{"} //"
  require BaseRing(sig) cmpeq GF(2) and Dimension(Parent(sig)) eq 1 : "Wrong signature vector";
  return true, sig[1] eq 0 select [K | 1] else [K | -1];
end intrinsic;

intrinsic UnitWithSignature(K::RngInt, sig::ModTupFldElt) -> BoolElt, SeqEnum
{"} //"
  require BaseRing(sig) cmpeq GF(2) and Dimension(Parent(sig)) eq 1 : "Wrong signature vector";
  return true, sig[1] eq 0 select [1] else [-1];
end intrinsic;

intrinsic UnitWithSignature(R::RngOrd[RngInt], sig::ModTupFldElt) -> BoolElt, SeqEnum
  {"} //"
  ok, U:= UnitWithSignature(NumberField(R), sig);
  if ok then 
    return true, ChangeUniverse(U, R);
  end if;
  return false, _;
end intrinsic;

h:= func< x | x eq 1 select 0 else 1 >;
intrinsic UnitWithSigns(K::FldAlg[FldRat], oo::[PlcNumElt], Signs::[RngIntElt]) -> SeqEnum
{"}//"
  require #oo eq #Signs and Set(Signs) subset {-1,1}: "Wrong signs";
  require #oo eq 0 or NumberField(oo[1]) eq K : "Wrong infinite places";
  require forall{ inf: inf in oo | IsReal(inf) }: "The places must be real";
  U, f:= UnitGroup(K);
  U:= [ f(U.i): i in [1..Ngens(U)] ];
  M:= Matrix(GF(2), #oo, #U, [ [ h(Sign(Evaluate(u,inf))): inf in oo ] : u in U ] );
  s:= Vector(GF(2), [ h(s): s in Signs ]);
  ok, x, KK:= IsConsistent(M, s);
  if not ok then return []; end if;
  return [ PowerProduct(U, ChangeUniverse(Eltseq(x+b), Integers())) : b in KK ];
end intrinsic;

intrinsic UnitWithSigns(K::FldRat, oo::[Infty], Signs::[RngIntElt]) -> SeqEnum
{"}//"
  require #oo eq #Signs and Set(Signs) subset {-1,1}: "Wrong signs";
  if   #Set(Signs) gt 1 then return [];
  elif #Set(Signs) eq 0 then return [1,-1];
  else return Signs[1..1];
  end if;
end intrinsic;


intrinsic MakeTotallyPositive(x::FldAlgElt[FldRat]) -> BoolElt, SeqEnum
{Returns true iff there exists some unit u in Z_K with u*x totally positive.
 If this is the case, then the second return value lists all such units u (modulo squares)}
    
  ok, U:= UnitWithSignature(Parent(x), SignatureGF2(x));
  if ok then
    return true, [x*u: u in U];
  else
    return false, _;
  end if;
end intrinsic;

intrinsic MakeTotallyPositive(x::FldRatElt) -> BoolElt, SeqEnum
{"} //"
  return true, [Sign(x)*x];
end intrinsic;

intrinsic MakeTotallyPositive(x::RngIntElt) -> BoolElt, SeqEnum
{"} //"
  return true, [Sign(x)*x];
end intrinsic;

intrinsic MakeTotallyPositive(x::RngOrdElt[RngInt]) -> BoolElt, SeqEnum
{"} //"
  R:= Parent(x);
  ok, U:= MakeTotallyPositive(NumberField(R) ! x);
  if ok then 
    return true, ChangeUniverse(U, R);
  end if;
  return false, _;
end intrinsic;

intrinsic HasTotallyPositiveGenerator(I::RngOrdFracIdl) -> BoolElt, []
{Check if I can be generated by a totally positive element. If so, the 
 second return value is such a generator}

 ok, x:= IsPrincipal(I);
 if not ok then return false, _; end if;
 return MakeTotallyPositive(x);
end intrinsic;

/*
intrinsic FindFullSpace(K::FldAlg: Primes := []) -> SetEnum, FldAlgElt
{}
  M:= SignatureMatrix(K);
  R:= Integers(K);
  L:= {Integers() | };
  p:= 1;
  r:= Rank(M);
  n:= Ncols(M);
  if (r eq n) then return L, M; end if;

  repeat
    if not IsEmpty(Primes) then
      p:= Primes[1];
      Remove(~Primes, 1);
    else
      p:= NextPrime(p);
    end if;
    F:= Factorization(p*R);
    for f in F do
      ok, x:= IsPrincipal(f[1]);
      if ok then
    //  if (ok and (Abs(Norm(x)) eq p)) then
        M2:= VerticalJoin(M, Matrix(SignatureGF2(K ! x)));
        r2:= Rank(M2);
        if (r lt r2) then
          r:= r2; M:= M2;
          Include(~L, p);
          if (r eq n) then break; end if;
        end if;
      end if;
    end for; 
  until (r eq n); 
  return L, M;
end intrinsic;

*/
